// foodtruckdbserver/libs package implements a FoodTruck Database processing 
// server (FTServer). This a read heavy servern and needs to highly scaled.
// This server provides following RPCs for application server:
// 
// * UpdateFoodTruck - updates a registered user's food truck location status.
// * CloseFoodTruck - closes down the service of a food truck.
// * FindNearestFoodTruck - Finds the nearest available food truck of a particular location.
//
// An instance of this FTServer can be generated by calling New() method and to 
// start the server, it needs to call blocked Start() method of FTserver instance.
// Currently it gets updated with recent data after certain interval whichs need to be 
// passed in constructoe method (New()) during instantiating the server.
//
// This server integrates with both UserDbManager and FoodTruckDbManager instance. So all the 
// processing logic (i,e, personalization) should be implemented in here.

package libs

import (
	"fmt"
	"log"
	"strconv"
	"net"
	"net/rpc"
	"sync"
	"time"

	"common"
)

type FTServer struct {
	ftDbMgr common.FoodTruckDbManager
	uDbMgr common.UserDbManager
    container common.DataContainer

    // cluster index of the data it currently holds in memory by container object.
    curCluster int

    lastUpdTime time.Time
    updInterval time.Duration

    mu sync.Mutex
}

func New(ftmgr common.FoodTruckDbManager, umgr common.UserDbManager, c common.DataContainer, updInterval time.Duration) *FTServer {
	srv := &FTServer{
		ftDbMgr: ftmgr,
		uDbMgr: umgr,
		container: c,
		updInterval: updInterval,
	}
	srv.updateContainer()
	return srv
}

func (srv *FTServer) Start(port int) {
	fmt.Println("Food Truck Database server starting ...")
	rpc.Register(srv)
	
	fmt.Println("Food Truck Database server opening tcp port ...")
	l, err := net.Listen("tcp", ":" + strconv.Itoa(port))
	if err != nil {
		log.Fatal("listen error:", err)
	}
	fmt.Println("Food Truck Database server successfully started ...")
	rpc.Accept(l)
}

// updateContainer fetches the updated data from database and builds the DataContainer
// by the recent data. It builds the DataContainer lazily. 
func (srv *FTServer) updateContainer() {
	if curTime := time.Now(); curTime.Sub(srv.lastUpdTime) < srv.updInterval {
		return
	}

	srv.mu.Lock()
	defer srv.mu.Unlock()

	if curTime := time.Now(); curTime.Sub(srv.lastUpdTime) < srv.updInterval {
		return
	}
	locs := srv.ftDbMgr.ClusterData(srv.curCluster)
	srv.container.Generate(locs)
	srv.lastUpdTime = time.Now()
}

// processFoodTruck integrates the data from both FoodTruckDBManager and UserDbManager.
func (srv *FTServer) processFoodTruck(list []*common.Location) []*common.TruckData {
	tds := []*common.TruckData{}
	for _, loc := range list {
		tds = append(tds, &common.TruckData{
			UID: loc.ID,
			Lat: loc.Lat,
			Lon: loc.Lon,
			Cuisine: srv.uDbMgr.CuisineType(loc.ID),
			})
	}
	return tds
}

// RPC methods

func (srv *FTServer) UpdateFoodTruck(td *common.TruckData, ok *bool) error {
	if err := srv.CloseFoodTruck(td, ok); err != nil {
		return err
	}
	*ok = srv.ftDbMgr.UpdateFoodTruck(td.UID, td.Lat, td.Lon, 0)
	return nil
}

func (srv *FTServer) CloseFoodTruck(td *common.TruckData, ok *bool) error {
	*ok = srv.ftDbMgr.CloseFoodTruck(td.UID)
	return nil
}

func (srv *FTServer) FindNearestFoodTruck(loc *common.Location, list *[]*common.TruckData) error {
	srv.updateContainer()
	locs := srv.container.KNearestNeighbour(loc, loc.Payload)
	*list = srv.processFoodTruck(locs)
	return nil
}
